#+TITLE: Goblins documentation: a draft rewrite

This is a draft of a rewrite of the documentation for Goblins.

* What is Goblins?

Goblins is a quasi-functional distributed object system.
Its design allows for object-capability security, allowing for safe
distributed programming environments.
Its design is inspired by the [[http://www.erights.org/][E programming language]]
and by the observation that
[[http://mumble.net/~jar/pubs/secureos/secureos.html][lambda is already the ultimate security mechanism]]
(ie, normal argument-passing in programs, if taken seriously/purely,
is already all the security system we need).

** What works so far?

 - *Quasi-functional object system:* Users hold on to references of
   objects/actors, but objects/actors are just procedures.  Rather
   than directly mutating, objects/actors can specify that they should
   "become" a new version of themselves when they handle the next
   invocation.

 - *Transactional updates:* Changes happen within a transaction.  If
   an unhandled exception occurs, we can "roll back" history as if the
   message never happened, avoiding confused state changes throughout
   the system.

 - *Time travel:* We can snapshot old revisions of the system and
   interact with them.

 - *Asynchronous programming with sophisticated promise chaining:*
   Asynchronous message passing with promises is supported.
   Promises work such that there's no need to wait for promises
   to resolve before interacting... you can communicate with the
   future that doesn't even yet exist!
   Sent a message to that remote car factory asking for a new car?
   Why wait for the car to be delivered... you can send it a drive
   message at the same time, and both messages can be delivered across
   the network in a single hop.

 - *Communicating event loops:*
   Objects across multiple event loops (aka "vats") can communicate,
   whether in the same OS process or (soon) across the network.

 - *Synchronous and asynchronous behavior, integrated but distinguished*:
   Both synchronous and asynchronous programming is supported, but
   only objects in the same "vat" (event loop) can perform synchronous
   immediate calls.
   All objects can perform asynchronous calls against each other.

 - *A library, not a language:*
   Goblins is itself a library that can be utilized with nearly any
   Racket program, including many Racket #langs.
   (However, some languages may be provided or encouraged for additional
   security / convenience later).

 - *Object capability security:*
   Goblins itself is built for object capability (ocap) security,
   which is to say that you can only operate on the references you
   have access to.
   Goblins embraces and builds upon this foundation.
   (However, full ocap security will require a safer module system than
   the one Racket provides; coming eventually.)

** What's on its way?

 - *Fully distributed, networked, secure p2p communication:*
   In the future, it will be possible to communicate with other
   objects over a network connection.
   Distributed object interactions is safe because of ocap security
   guarantees.
 - *A separate module system:*
   While not part of Goblins itself, a future project named
   "Spritely Dungeon" will help close the loop on ocap security for
   Racket.

* A tutorial

** Vats, actors, spawning, and immediate calls

Let's open a Racket REPL and import Goblins:

#+BEGIN_SRC racket
(require goblins)
#+END_SRC

First we're going to need something to store our objects in.
We'll boot up an event loop, called a "vat" (TODO: explain why it's
called that), which can manage our objects.

#+BEGIN_SRC racket
(define a-vat
  (make-vat))
#+END_SRC

Our vat is currently lonely... nobody lives in it!
Let's make a friend.
First we'll need a friend constructor:

#+BEGIN_SRC racket
;; The ^ is conventionally called a "hard hat" in Goblins; it means
;; this is an object constructor.
;; Every constructor takes a bcom argument, the rest of them are
;; passed in from the spawn invocation.
(define (^friend bcom my-name)
  ;; This is the initial handler procedure.
  (lambda (your-name)
    (format "Hello ~a, my name is ~a!" your-name my-name)))
#+END_SRC

The outer procedure is the constructor; all it really does is return
another procedure which is the handler.

Let's make a friend and call her Alice.

#+BEGIN_SRC racket
(define alice
  (a-vat 'spawn ^friend "Alice"))
#+END_SRC

Here the arguments to the spawn method are ^friend, which is the
constructor procedure we are using, and the argument "Alice", which
becomes bound to =my-name=.
(The =bcom= argument is implicitly provided by Goblins; we'll ignore
it for right now.)

If we look at Alice in the REPL, we'll see that what we're really
holding onto is a "live reference" to Alice.

#+BEGIN_SRC racket
> alice
#<live-refr ^friend>
#+END_SRC

Now we'd like to talk to Alice.
For now let's use the "call" method on our vat:

#+BEGIN_SRC racket
> (a-vat 'call alice "Chris")
"Hello Chris, my name is Alice!"
#+END_SRC

If we look at our =^friend= procedure again, this should make a lot of
sense; the inner lambda is being evaluated with "Chris" being passed in
for =your-name=.
The returned value is just the result.

Normally in a Goblins program, we can just spawn and talk to a Goblins
object directly using the =spawn= and =$= operators directly.
However we're kind of "bootstrapping the world" here, so we need the
vat's help to do that.
However, we can see what it would look like to use them if we were in
a "Goblins context" by using the vat's ='run= method which allows us
to pass in an arbitrary thunk (aka "procedure with no arguments"):

#+BEGIN_SRC racket
> (a-vat 'run
         (lambda ()
           (define alyssa
             (spawn ^friend "Alyssa"))
           ($ alyssa "Ben")))
"Hello Ben, my name is Alyssa!"
#+END_SRC

Anyway, maybe we'd like to be greeted the same way we have been by our
friend sometimes, but other times we'd like to just find out what our
friend's name is.
It would be nice to have different "methods" we could call, and in
fact, Goblins comes with a convenient =methods= macro:

#+BEGIN_SRC racket
(require goblins/actor-lib/methods)

(define (^methods-friend bcom my-name)
  (methods
   ;; Greet the user using their name
   [(greet your-name)
    (format "Hello ~a, my name is ~a!" your-name my-name)]
   ;; return what our name is
   [(name)
    my-name]))
#+END_SRC

Now let's spawn an alice2 that uses =^methods-friend=:

#+BEGIN_SRC racket
(define alice2
  (a-vat 'spawn ^methods-friend "Alice"))
#+END_SRC

Now we can call each method separately:

#+BEGIN_SRC racket
> (a-vat 'call alice2 'name)
"Alice"
> (a-vat 'call alice2 'greet "Chris")
"Hello Chris, my name is Alice!"
#+END_SRC

(As a side note, if you're thinking that it would look nicer if this
looked like:)

#+BEGIN_SRC racket
> (a-vat.call alice2.name)
"Alice"
> (a-vat.call alice2.greet "Chris")
"Hello Chris, my name is Alice!"
#+END_SRC

(... you're right and a =#lang= will provided in the future for such
aesthetic improvement which expands to the former syntax.)

What kind of magic is this methods thing?
Well actually it's barely any magic at all.
Methods just returns a procedure that dispatches on the first argument,
a symbol, to one of several procedures.
We can even use it outside of an object/actor constructor:

#+BEGIN_SRC racket
> (define what-am-i
    (methods
     [(i-am)
      (list 'i 'am 'just 'a 'procedure)]
     [(that what)
      (list 'that 'calls 'other what)]))
> (what-am-i 'i-am)
'(i am just a procedure)
> (what-am-i 'that 'procedures)
'(that calls other procedures)
#+END_SRC

We could have just as well written methods-friend like so:

#+BEGIN_SRC racket
  (define (^match-friend bcom my-name)
    (match-lambda*
     ;; Greet the user using their name
     [(list 'greet your-name)
      (format "Hello ~a, my name is ~a!" your-name my-name)]
     ;; return what our name is
     [(list 'name)
      my-name]))
#+END_SRC

But it's a lot nicer to use =methods=.
But the key thing to realize is that =methods= just itself returns
another procedure.

Maybe we'd like to keep track of how many times our friend has been
called.
It might be helpful to have some kind of helper object which can do
that.
What if we made a counter?

#+BEGIN_SRC racket
(define (^counter bcom [count 0])
  (methods
   ;; return the current count
   [(count)
    count]
   ;; Add one to the current counter
   [(add1)
    (bcom (^counter bcom (add1 count)))]))
#+END_SRC

Now let's spawn and poke at an instance of that counter a bit:

#+BEGIN_SRC racket
> (define a-counter
    (a-vat 'spawn ^counter))
> (a-vat 'call a-counter 'count)
0
> (a-vat 'call a-counter 'add1)
> (a-vat 'call a-counter 'count)
1
> (a-vat 'call a-counter 'add1)
> (a-vat 'call a-counter 'add1)
> (a-vat 'call a-counter 'count)
3
#+END_SRC

Now note that our counter actually appears to change... how does this
happen?
Let's look at the body of that add1 method in detail:

#+BEGIN_SRC racket
  (bcom (next (add1 count)))
#+END_SRC

=bcom= (pronounced "be-come" or "be-comm") is the capability to
"become" a new version of ourselves; more explicitly, to give a
procedure which will be called the /next time/ this object is invoked.
=next= returns some methods wrapped up in a closure which knows
what the count is; we're incrementing that by one from whatever
we currently have.
(Depending on how experienced you are with functional programming is
how confusing this is likely to be.)

There are multiple equivalent ways we could build the "next" procedure
we are becoming for ourselves, and one is to build an actual =next=
builder and instantiate it once.
This technique is exactly equivalent to the above, and we will use this
kind of structure later, so it's worth seeing and realizing it's more
or less the same (except that we didn't expose the choice of an initial
count value):

#+BEGIN_SRC racket
  (define (^counter bcom)
    (define (next count)
      (methods
       ;; return the current count
       [(count)
        count]
       ;; Add one to the current counter
       [(add1)
        ;; Become the next version of ourselves,
        ;; with count incremented
        (bcom (next (add1 count)))]))
    ;; We'll start at 0.
    (next 0))
#+END_SRC

Now that we have this counter, we can rewrite our friend to spawn it
and use it:

#+BEGIN_SRC racket
(define (^counter-friend bcom my-name)
  (define greet-counter
    (spawn ^counter))
  (methods
   ;; Greet the user using their name
   [(greet your-name)
    ;; Increment count by one, since we were just called.
    ;; The counter starts at 0 so this will be correct.
    ($ greet-counter 'add1)
    (define greet-count
      ($ greet-counter 'count))
    (format "Hello ~a, my name is ~a and I've greeted ~a times!" 
            your-name my-name greet-count)]
   ;; return what our name is
   [(name)
    my-name]
   ;; check how many times we've greeted, without
   ;; incrementing it
   [(greet-count)
    ($ greet-counter 'count)]))
#+END_SRC

You'll observe that there was no need to go through the vat here,
our object was able to use =spawn= and =$= (which is pronounced "call",
"immediate call", or "money call") directly.
That's because our actor is operating within a goblins context, so
there's no reason to do so by bootstrapping through the vat (indeed,
trying to do so would cause an exception to be raised).

Now let's give it a try:

#+BEGIN_SRC racket
> (define alice3
    (a-vat 'spawn ^counter-friend "Alice"))
> (a-vat 'call alice3 'greet "Chris")
"Hello Chris, my name is Alice and I've greeted 1 times!"
> (a-vat 'call alice3 'greet "Chris")
"Hello Chris, my name is Alice and I've greeted 2 times!"
> (a-vat 'call alice3 'greet-count)
2
> (a-vat 'call alice3 'greet "Chris")
"Hello Chris, my name is Alice and I've greeted 3 times!"
> (a-vat 'call alice3 'greet-count)
3
#+END_SRC

Perhaps we'd like to have our friend remember the last person she
was called by.
It would be nice if there were something along the lines of a mutable
variable we could change.
In fact there is, and it's called a cell.
When called with no arguments, a cell returns its current value.
When called with one argument, a cell replaces its current value with
the one we have provided:

#+BEGIN_SRC racket
> (require goblins/actor-lib/cell)
> (define treasure-chest
    (a-vat 'spawn ^cell 'gold))
> (a-vat 'call treasure-chest)
'gold
> (a-vat 'call treasure-chest 'flaming-sword)
> (a-vat 'call treasure-chest)
'flaming-sword
#+END_SRC

A fun exercise is to try to write your own cell.
Here is one way:

#+BEGIN_SRC racket
;; Constructor for a cell.  Takes an optional initial value, defaults
;; to false.
(define (^our-cell bcom [val #f])
  (case-lambda
    ;; Called with no arguments; return the current value
    [() val]
    ;; Called with one argument, we become a version of ourselves
    ;; with this new value
    [(new-val)
     (bcom (^our-cell bcom new-val))]))
#+END_SRC

Of course, you could also have a cell that instead has ='get= and
='set= methods.
This is left as an exercise for the reader.

Now that we have cells, we can use them:

#+BEGIN_SRC racket
(define (^memory-friend bcom my-name)
  (define greet-counter
    (spawn ^counter))
  (define recent-friend
    (spawn ^cell #f))
  (methods
   ;; Greet the user using their name
   [(greet your-name)
    ;; Increment count by one, since we were just called.
    ;; The counter starts at 0 so this will be correct.
    ($ greet-counter 'add1)
    (define greet-count
      ($ greet-counter 'count))
    ;; Who our friend was last time
    (define last-friend-name
      ($ recent-friend))
    ;; But now let's set the recent friend to be this name
    ($ recent-friend your-name)
    (if last-friend-name
        (format "Hello ~a, my name is ~a and I've greeted ~a times (last by ~a)!" 
                your-name my-name greet-count last-friend-name)
        (format "Hello ~a, my name is ~a and I've greeted ~a times!" 
                your-name my-name greet-count))]
   ;; return what our name is
   [(name)
    my-name]
   ;; check how many times we've greeted, without
   ;; incrementing it
   [(greet-count)
    ($ greet-counter 'count)]))
#+END_SRC

Let's try interacting with this friend:

#+BEGIN_SRC racket
> (define alice4
    (a-vat 'spawn ^memory-friend "Alice"))
> (a-vat 'call alice4 'greet "Chris")
"Hello Chris, my name is Alice and I've greeted 1 times!"
> (a-vat 'call alice4 'greet "Carl")
"Hello Carl, my name is Alice and I've greeted 2 times (last by Chris)!"
> (a-vat 'call alice4 'greet "Carol")
"Hello Carol, my name is Alice and I've greeted 3 times (last by Carl)!"
#+END_SRC

Whew... if we look at that code for the =greet= code, it sure looks
fairly imperative, though.
We pulled out the value from =recent-friend= before we changed
it.
If we had accidentlaly put the definition for =last-friend-name=
after setting =recent-friend= to =your-name=, we might have resulted in
a classic imperative error and =last-friend-name= would be set to the
new one instead of the old one!

Well, it turns out that =bcom= can take a second argument which
provides a value it would like to return in addition to specifying the
new version of itself it would like to become.
This means that we could rewrite =^memory-friend= like so with no
behavioral differences:

#+BEGIN_SRC racket
(define (^memory-friend2 bcom my-name)
  (define (next greet-count last-friend-name)
    (methods
     ;; Greet the user using their name
     [(greet your-name)
      (define greeting
        (if last-friend-name
            (format "Hello ~a, my name is ~a and I've greeted ~a times (last by ~a)!" 
                    your-name my-name greet-count last-friend-name)
            (format "Hello ~a, my name is ~a and I've greeted ~a times!" 
                    your-name my-name greet-count)))
      (bcom (next (add1 greet-count)
                  your-name)
            greeting)]
     ;; return what our name is
     [(name)
      my-name]
     ;; check how many times we've greeted, without
     ;; incrementing it
     [(greet-count)
      greet-count]))
  (next 1 #f))
#+END_SRC

#+BEGIN_SRC racket
> (define alice5
    (a-vat 'spawn ^memory-friend2 "Alice"))
> (a-vat 'call alice5 'greet "Chris")
"Hello Chris, my name is Alice and I've greeted 1 times!"
> (a-vat 'call alice5 'greet "Carl")
"Hello Carl, my name is Alice and I've greeted 2 times (last by Chris)!"
> (a-vat 'call alice5 'greet "Carol")
"Hello Carol, my name is Alice and I've greeted 3 times (last by Carl)!"
#+END_SRC

This certainly looks more functional, and we have some freedom of how
we'd like to implement it.
It also leads to the observation that the behavior of objects in
respect to updating themselves appears to be very functional (returning
a new version of ourselves and maybe a value), whereas calling other
objects appears to be very imperative.

So what is the point of cells and counters?
After all, if we're using =#lang racket= we have access to the =set!=
procedure, and could have easily rewritten the =^counter= and =^cell=
versions like so:

#+BEGIN_SRC racket
(define (^imperative-friend bcom my-name)
  (define greet-count
    0)
  (define recent-friend
    #f)
  (methods
   ;; Greet the user using their name
   [(greet your-name)
    ;; Increment count by one, since we were just called.
    ;; The counter starts at 0 so this will be correct.
    (set! greet-count (add1 greet-count))
    ;; Who our friend was last time
    (define last-friend-name
      recent-friend)
    ;; But now let's set the recent friend to be this name
    (set! recent-friend your-name)
    (if last-friend-name
        (format "Hello ~a, my name is ~a and I've greeted ~a times (last by ~a)!" 
                your-name my-name greet-count last-friend-name)
        (format "Hello ~a, my name is ~a and I've greeted ~a times!" 
                your-name my-name greet-count))]
   ;; return what our name is
   [(name)
    my-name]
   ;; check how many times we've greeted, without
   ;; incrementing it
   [(greet-count)
    greet-count]
   [(recent-friend)
    recent-friend]))
#+END_SRC

Usage is exactly the ssame:

#+BEGIN_SRC racket
> (define alice6
    (a-vat 'spawn ^imperative-friend "Alice"))
> (a-vat 'call alice6 'greet "Chris")
"Hello Chris, my name is Alice and I've greeted 1 times!"
> (a-vat 'call alice6 'greet "Carl")
"Hello Carl, my name is Alice and I've greeted 2 times (last by Chris)!"
> (a-vat 'call alice6 'greet "Carol")
"Hello Carol, my name is Alice and I've greeted 3 times (last by Carl)!"
#+END_SRC

This code looks mostly the same too, and indeed maybe even a little
simpler with =set!= (no mucking around with that =$= malarky).

Let's introduce a couple of bugs into both the cell-using and
the =set!= using imperative versions of these friends:

#+BEGIN_SRC racket
(define (^buggy-memory-friend bcom my-name)
  (define greet-counter
    (spawn ^counter))
  (define recent-friend
    (spawn ^cell #f))
  (methods
   ;; Greet the user using their name
   [(greet your-name)
    ;; Increment count by one, since we were just called.
    ;; The counter starts at 0 so this will be correct.
    ($ greet-counter 'add1)
    (define greet-count
      ($ greet-counter 'count))
    ;; Who our friend was last time
    (define last-friend-name
      ($ recent-friend))
    ;; But now let's set the recent friend to be this name
    ($ recent-friend your-name)
    (error "AHH! Throwing an error after I changed things!")
    (if last-friend-name
        (format "Hello ~a, my name is ~a and I've greeted ~a times (last by ~a)!" 
                your-name my-name greet-count last-friend-name)
        (format "Hello ~a, my name is ~a and I've greeted ~a times!" 
                your-name my-name greet-count))]
   ;; return what our name is
   [(name)
    my-name]
   ;; check how many times we've greeted, without
   ;; incrementing it
   [(greet-count)
    ($ greet-counter 'count)]))

(define (^buggy-imperative-friend bcom my-name)
  (define greet-count
    0)
  (define recent-friend
    #f)
  (methods
   ;; Greet the user using their name
   [(greet your-name)
    ;; Increment count by one, since we were just called.
    ;; The counter starts at 0 so this will be correct.
    (set! greet-count (add1 greet-count))
    ;; Who our friend was last time
    (define last-friend-name
      recent-friend)
    ;; But now let's set the recent friend to be this name
    (set! recent-friend your-name)
    (error "AHH! Throwing an error after I changed things!")
    (if last-friend-name
        (format "Hello ~a, my name is ~a and I've greeted ~a times (last by ~a)!" 
                your-name my-name greet-count last-friend-name)
        (format "Hello ~a, my name is ~a and I've greeted ~a times!" 
                your-name my-name greet-count))]
   ;; return what our name is
   [(name)
    my-name]
   ;; check how many times we've greeted, without
   ;; incrementing it
   [(greet-count)
    greet-count]))
#+END_SRC

(Observe the =error= put after both of them changed =greet-count=
and =recent-friend=.)

Okay, first let's check the initial =greet-count=:

#+BEGIN_SRC racket
> (a-vat 'call buggy-gobliny-alice 'greet-count)
0
> (a-vat 'call buggy-imperative-alice 'greet-count)
0
#+END_SRC

So far, so good.
Now let's greet both of them:

#+BEGIN_SRC racket
> (a-vat 'call buggy-gobliny-alice 'greet "Chris")
; AHH! Throwing an error after I changed things!
; Context:
;  /home/cwebber/devel/goblins/goblins/core.rkt:498:5
;  /home/cwebber/devel/goblins/goblins/core.rkt:903:3
;  /home/cwebber/devel/goblins/goblins/core.rkt:433:0 call-with-fresh-syscaller
;  /gnu/store/xpivjjmjgcc3l3415dcvb4pm5xrbrm3i-racket-7.3/share/racket/collects/racket/match/compiler.rkt:507:40 f71
> (a-vat 'call buggy-imperative-alice 'greet "Chris")
; AHH! Throwing an error after I changed things!
; Context:
;  /home/cwebber/devel/goblins/goblins/core.rkt:498:5
;  /home/cwebber/devel/goblins/goblins/core.rkt:903:3
;  /home/cwebber/devel/goblins/goblins/core.rkt:433:0 call-with-fresh-syscaller
;  /gnu/store/xpivjjmjgcc3l3415dcvb4pm5xrbrm3i-racket-7.3/share/racket/collects/racket/match/compiler.rkt:507:40 f71
#+END_SRC

Okay, so both of them threw the error.
But what do you think the result of =greet-count= will be now?

#+BEGIN_SRC racket
> (a-vat 'call buggy-gobliny-alice 'greet-count)
0
> (a-vat 'call buggy-imperative-alice 'greet-count)
1
#+END_SRC

Now this is definitely different!
In the goblin'y example, by using goblin objects/actors, unhandled
errors means that breakage is as if nothing ever occurred.
We can log the error, but we won't mess up the rest of the system.
With the imperative code which uses =set!=, the state of our system
could become unintentionally corrupted and inconsistent.

This is what we mean by Goblins being transactional: something that
goes wrong need not be "committed" to the current state.
This is important for systems like financial infrastructure.
It turns out it also opens us up, in general, to becoming
[[https://dustycloud.org/blog/goblins-time-travel-micropreview/][time wizards]].
But more on that later.

** Message passing, promises, and multiple vats

*** The basics

Remember simpler times, when friends mostly just greeted us hello?

#+BEGIN_SRC racket
(define (^friend bcom my-name)
  (lambda (your-name)
    (format "Hello ~a, my name is ~a!" your-name my-name)))

(define alice
  (a-vat 'spawn ^friend "Alice"))
#+END_SRC

We could of course make another friend that talks to Alice.

#+BEGIN_SRC racket
(define (^calls-friend bcom our-name)
  (lambda (friend)
    (define what-my-friend-said
      ($ friend our-name))
    (displayln (format "<~a>: I called my friend, and they said:"
                       our-name))
    (displayln (format "   \"~a\"" what-my-friend-said))))

(define archie
  (a-vat 'spawn ^calls-friend "Archie"))
#+END_SRC

Now Archie can talk to Alice:

#+BEGIN_SRC racket
> (a-vat 'call archie alice)
<Archie>: I called my friend, and they said:
   "Hello Archie, my name is Alice!"
#+END_SRC

Both Alice and Archie live in =a-vat=.
But =a-vat= isn't the only vat in town.  One other such vat
is =b-vat=, where Bob lives:

#+BEGIN_SRC racket
(define b-vat
  (make-vat))

(define bob
  (b-vat 'spawn ^calls-friend "Bob"))
#+END_SRC

Obviously, since Bob is in =b-vat=, we bootstrap a message call to Bob
from =b-vat=.
But what do you think happens when Bob tries to call Alice?

#+BEGIN_SRC racket
> (b-vat 'call bob alice)
; not-callable: Not in the same vat: #<live-refr ^friend>
; Context:
;  /home/cwebber/devel/goblins/goblins/core.rkt:542:5
;  /home/cwebber/sandbox/goblins-tut.rkt:240:2
;  /home/cwebber/devel/goblins/goblins/core.rkt:498:5
;  /home/cwebber/devel/goblins/goblins/core.rkt:903:3
;  /home/cwebber/devel/goblins/goblins/core.rkt:433:0 call-with-fresh-syscaller
;  /gnu/store/xpivjjmjgcc3l3415dcvb4pm5xrbrm3i-racket-7.3/share/racket/collects/racket/match/compiler.rkt:507:40 f71
#+END_SRC

Oh no!
It looks like Bob can't call Alice since they live in different
places!
From Archie's perspective, Alice was "near", aka "in the same vat".
However from Bob's perspective Alice was "far", aka "in some other
vat that isn't the one I'm in".
This is a problem because using the =$= operator performs a
/synchronous/ call, but it's only safe to do synchronous calls for
objects that are near each other (in the same vat).

Fortunately there's something we can do: we can send a message from
Bob to Alice.
But we've never seen message sending in Goblins before, so what is that?

To prototype this, let's use the ='run= method on =b-vat=.
Remember, we saw the ='run= method used before, where it looked like:

#+BEGIN_SRC racket
> (a-vat 'run
         (lambda ()
           (define alyssa
             (spawn ^friend "Alyssa"))
           ($ alyssa "Ben")))
"Hello Ben, my name is Alyssa!"
#+END_SRC

So ='run= is just a way to run some arbitrary code in an actor context.
That sounds good enough for playing around with sending messages.
We can send messages with =<-= so let's try that:

#+BEGIN_SRC racket
> (b-vat 'run
         (lambda ()
           (<- alice "Brenda")))
#<live-refr promised>
#+END_SRC

Ah ok... so what =<-= returns is something called a "Promise" which
might eventually be resolved to something interesting.
We want some way to be able to pull out that interesting thing.
That's what =on= is for: it resolves promises and pulls out their
resolved value:

#+BEGIN_SRC racket
> (b-vat 'run
         (lambda ()
           (on (<- alice "Brenda")
               (lambda (alice-says)
                 (displayln (format "Got from Alice: ~a" alice-says))))))
Got from Alice: Hello Brenda, my name is Alice!
#+END_SRC

=<-= works just fine with far references, but it also works just fine
with near references too!
So we can run the same code in a-vat (where Alice is "near") and it
works there too:

#+BEGIN_SRC racket
> (a-vat 'run
         (lambda ()
           (on (<- alice "Arthur")
               (lambda (alice-says)
                 (displayln (format "Got from Alice: ~a" alice-says))))))
Got from Alice: Hello Arthur, my name is Alice!
#+END_SRC

So using =on= and =<-= seems to fit our needs.
But what would have happened if Alice had thrown an error?
Indeed, if we remember earlier we made =buggy-gobliny-alice=
so we can test for that.
It turns out that on can take a =#:catch= argument:

#+BEGIN_SRC racket
> (b-vat 'run
         (lambda ()
           (on (<- buggy-gobliny-alice 'greet "Brenda")
               (lambda (alice-says)
                 (displayln (format "Got from Alice: ~a" alice-says)))
               #:catch
               (lambda (err)
                 (displayln "Tried to talk to Alice, got an error :(")))))
;; === While attempting to send message: ===
; AHH! Throwing an error after I changed things!
; Context:
;  /home/cwebber/devel/goblins/goblins/core.rkt:498:5
;  /home/cwebber/devel/goblins/goblins/core.rkt:966:3
;  /home/cwebber/devel/goblins/goblins/core.rkt:433:0 call-with-fresh-syscaller
;  /home/cwebber/devel/goblins/goblins/vat.rkt:135:11 lp
Tried to talk to Alice, got an error :(
#+END_SRC

Now this is a little bit confusing to read because we saw two separate
messages here... it's important to realize that due to the way our vat
is configured, the exception backtrace being printed out is coming
from =a-vat=, not from our code being evaluated in =b-vat=.
We could configure the =a-vat= loop to do something different when it
hits errors, but currently it prints exceptions so we can debug them.
Anyway, so that's helpful information, but actually the place we caught
the error in /our/ code above was in the =lambda= right after =#:catch=.
As we can see, it did catch the error and we used that as an opportunity
to print out a complaint.

So =<-= makes a promise for us.
We don't always need a promise; sometimes we're just calling something
for its effects.
For instance we might have a parrot that we like to encourage to say
silly things, maybe on the screen or even out loud, but we don't care
much about the result.
In that case we can use =<-np= which sends a message but with "no
promise":

#+BEGIN_SRC racket
> (define parrot
    (a-vat 'spawn
           (lambda (bcom)
             (lambda (phrase)
               ;; Since we're using displayln, we're printing this phrase
               ;; rather than returning it as a string
               (displayln (format "<parrot>: ~a... *SQWAK!*" phrase))))))
> (b-vat 'run
         (lambda ()
           (<-np parrot "Polly wants a chiptune")))
<parrot>: Polly wants a chiptune... *SQWAK!*
#+END_SRC

When we don't need a promise, =<-np= is an optimization that saves us
from some promise overhead.
But in most of our code, =<-= performs the more common case
of returning a promise.

Anyway, we should have enough information to make a better constructor
for friends who are far away.
Recall our definition of =^calls-friend=:

#+BEGIN_SRC racket
(define (^calls-friend bcom our-name)
  (lambda (friend)
    (define what-my-friend-said
      ($ friend our-name))
    (displayln (format "<~a>: I called my friend, and they said:"
                       our-name))
    (displayln (format "   \"~a\"" what-my-friend-said))))
#+END_SRC

.. we'll make a few changes and name our constructor =^messages-friend=:

#+BEGIN_SRC racket
(define (^messages-friend bcom our-name)
  (lambda (friend)
    (on (<- friend our-name)
        (lambda (what-my-friend-said)
          (displayln (format "<~a>: I messaged my friend, and they said:"
                             our-name))
          (displayln (format "   \"~a\"" what-my-friend-said)))
        #:catch
        (lambda (err)
          (displayln
           "I messaged my friend but they broke their response promise...")))))
#+END_SRC

(We even made it a bit more robust than our previous implementation
by handling errors!)

Now we can make a version of Bob that can do a better job of holding a
conversation with his far-away friend Alice:

#+BEGIN_SRC racket
> (b-vat 'call bob2 alice)
<Bob>: I messaged my friend, and they said:
   "Hello Bob, my name is Alice!"
#+END_SRC

Much better!

*** More on promises

**** Making and resolving our own promises

So we know that =<-= can make promises, but it turns out we can
make promises ourselves:

#+BEGIN_SRC racket
> (a-vat 'run spawn-promise-cons)
'(#<live-refr promised> . #<live-refr ^resolver>)
#+END_SRC

As we can see, promises come in pairs: the promise object, which we
can listen to with =on=, and the resolver object, which lets us
fulfill or break a promise.

We can also use =spawn-promise-pair= to spawn a promise
(TODO: add footnote about why we didn't earlier, multiple value return
not being allowed from actors currently), which returns multiple
values (which we can bind with =define-values=).
We can then try resolving a promise with =on=... but of course
we'll need to fulfill or break it to see anything.

#+BEGIN_SRC racket
> (a-vat 'run
         (lambda ()
           (define-values (foo-vow foo-resolver)
             (spawn-promise-pair))
           (define-values (bar-vow bar-resolver)
             (spawn-promise-pair))
           (define (declare-resolved result)
             (printf "Resolved: ~a\n" result))
           (define (declare-broken err)
             (printf "Broken: ~a\n" err))
           (on foo-vow
               declare-resolved
               #:catch declare-broken)
           (on bar-vow
               declare-resolved
               #:catch declare-broken)
           ($ foo-resolver 'fulfill 'yeah-foo)
           ($ bar-resolver 'break 'oh-no-bar)))
Resolved: yeah-foo
Broken: oh-no-bar
#+END_SRC

By the way, you may notice that there's a naming convention in Goblins
(borrowed from E) to append a =-vow= suffix if something is a promise
(or should be treated as one).
That's a good practice for you to adopt, too.

**** Finally we have #:finally

Maybe we'd like to run something once a promise resolves, regardless
of whether or not it succeds or fails.
In such a case we can use the =#:finally= keyword:

#+BEGIN_SRC racket
> (a-vat 'run
         (lambda ()
           (define resolves-ok
             (spawn (lambda (bcom)
                      (lambda ()
                        "This is fine!"))))
           (define errors-out
             (spawn (lambda (bcom)
                      (lambda ()
                        (error "I am error!")))))
           (define (handle-it from-name vow)
             (on vow
                 (lambda (val)
                   (displayln
                    (format "Got from ~a: ~a" from-name val)))
                 #:catch
                 (lambda (err)
                   (displayln
                    (format "Error from ~a: ~a" from-name err)))
                 #:finally
                 (lambda ()
                   (displayln
                    (format "Done handling ~a." from-name)))))
           (handle-it 'resolves-ok (<- resolves-ok))
           (handle-it 'errors-out (<- errors-out))))
;; === While attempting to send message: ===
; I am error!
; Context:
;  /home/cwebber/devel/goblins/goblins/core.rkt:500:5
;  /home/cwebber/devel/goblins/goblins/core.rkt:967:0 actormap-turn-message86
;  /home/cwebber/devel/goblins/goblins/vat.rkt:135:11 lp
Got from resolves-ok: This is fine!
Done handling resolves-ok.
Error from errors-out: #(struct:exn:fail I am error! #<continuation-mark-set>)
Done handling errors-out.
#+END_SRC

**** "on" with non-promise values

=on= works just fine if you pass in a non-promise value.
It'll just treat that value as if it were a promise that had
resolved immediately.
For example:

#+BEGIN_SRC racket
> (a-vat 'run
         (lambda ()
           (on 5
               (lambda (v)
                 (displayln (format "Got: ~a" v))))))
Got: 5
#+END_SRC

**** "on" can return promises too

**** Promise pipelining

** Going low-level: actormaps

*TODO: write this*

** Networked object interactions

*Big ol' TODO here since we need to implement it, too!*

** Advanced object patterns

*TODO: write this*

* Core API

* Actormap API

* Vat API

* Distributed Goblins

TODO
